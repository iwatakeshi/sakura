import { SakuraNode } from "~src/structures/n-ary/sakura/node";
import { Nullable } from "~src/shared/types/ts";
import { Key } from "~src/shared/types/key";
import { find } from "~src/structures/n-ary/utils/find";


interface ISakuraTree<T> {
  map<U>(fn: (value: SakuraNode<T>, key: Key) => U): U[];
  reduce<U>(fn: (acc: U, value: SakuraNode<T>) => U, initial: U): U;
}

export class SakuraTree<T> implements ISakuraTree<T> {
  root: SakuraNode<T>
  constructor(root: SakuraNode<T>) {
    this.root = root
  }

  map<U>(fn: (value: SakuraNode<T>, key: Key) => U): U[] {
    const result: U[] = []
    const stack: SakuraNode<T>[] = [this.root]
    while (stack.length) {
      const node = stack.pop()
      if (node) {
        result.push(fn(node, node.key))
        stack.push(...node.children)
      }
    }
    return result
  }

  reduce<U>(fn: (acc: U, value: SakuraNode<T>) => U, initial: U): U {
    const stack: SakuraNode<T>[] = [this.root]
    let acc = initial
    while (stack.length) {
      const node = stack.pop()
      if (node) {
        
        acc = node.reduce(fn, acc)
        stack.push(...node.children)
      }
    }
    return acc
  }

  filter(fn: (value: SakuraNode<T>) => boolean): SakuraTree<T> {
    const stack: SakuraNode<T>[] = [this.root]
    const result: SakuraNode<T>[] = []
    while (stack.length) {
      const node = stack.pop()
      if (node) {
        if (fn(node)) {
          result.push(node)
        }
        stack.push(...node.children)
      }
    }
    return new SakuraTree(result[0])
  }
}